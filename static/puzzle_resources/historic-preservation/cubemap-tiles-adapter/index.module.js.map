{"version":3,"sources":["../src/CubemapTilesAdapter.ts","../../shared/Queue.ts","../../shared/tiles-utils.ts"],"sourcesContent":["import type { TextureData, Viewer } from '@photo-sphere-viewer/core';\nimport { AbstractAdapter, CONSTANTS, events, PSVError, utils } from '@photo-sphere-viewer/core';\nimport { CubemapAdapter } from '@photo-sphere-viewer/cubemap-adapter';\nimport {\n    BoxGeometry,\n    BufferAttribute,\n    Frustum,\n    ImageLoader,\n    MathUtils,\n    Matrix4,\n    Mesh,\n    MeshBasicMaterial,\n    Texture,\n    Vector2,\n    Vector3,\n} from 'three';\nimport { Queue, Task } from '../../shared/Queue';\nimport { buildErrorMaterial } from '../../shared/tiles-utils';\nimport { CubemapTilesAdapterConfig, CubemapTilesPanorama } from './model';\n\ntype CubemapMesh = Mesh<BoxGeometry, MeshBasicMaterial[]>;\ntype CubemapTexture = TextureData<Texture[]>;\ntype CubemapTile = { face: number; col: number; row: number; angle: number };\n\nconst CUBE_SEGMENTS = 16;\nconst NB_VERTICES_BY_FACE = 6;\nconst NB_VERTICES_BY_PLANE = NB_VERTICES_BY_FACE * CUBE_SEGMENTS * CUBE_SEGMENTS;\nconst NB_VERTICES = 6 * NB_VERTICES_BY_PLANE;\nconst NB_GROUPS_BY_FACE = CUBE_SEGMENTS * CUBE_SEGMENTS;\n\nconst CUBE_HASHMAP = ['left', 'right', 'top', 'bottom', 'back', 'front'];\n\nconst ATTR_UV = 'uv';\nconst ATTR_ORIGINAL_UV = 'originaluv';\nconst ATTR_POSITION = 'position';\n\nfunction tileId(tile: CubemapTile) {\n    return `${tile.face}:${tile.col}x${tile.row}`;\n}\n\nconst getConfig = utils.getConfigParser<CubemapTilesAdapterConfig>({\n    flipTopBottom: false,\n    showErrorTile: true,\n    baseBlur: true,\n    blur: false,\n});\n\nconst frustum = new Frustum();\nconst projScreenMatrix = new Matrix4();\nconst vertexPosition = new Vector3();\n\n/**\n * Adapter for tiled cubemaps\n */\nexport class CubemapTilesAdapter extends AbstractAdapter<CubemapTilesPanorama, Texture[]> {\n    static override readonly id = 'cubemap-tiles';\n    static override readonly supportsDownload = false;\n    static override readonly supportsOverlay = false;\n\n    private readonly config: CubemapTilesAdapterConfig;\n\n    private readonly state = {\n        tileSize: 0,\n        facesByTile: 0,\n        tiles: {} as Record<string, boolean>,\n        geom: null as BoxGeometry,\n        materials: [] as MeshBasicMaterial[],\n        errorMaterial: null as MeshBasicMaterial,\n    };\n\n    private adapter: CubemapAdapter;\n    private readonly queue = new Queue();\n    private readonly loader?: ImageLoader;\n\n    constructor(viewer: Viewer, config: CubemapTilesAdapterConfig) {\n        super(viewer);\n\n        this.config = getConfig(config);\n\n        if (this.viewer.config.requestHeaders) {\n            utils.logWarn(\n                'CubemapTilesAdapter fallbacks to file loader because \"requestHeaders\" where provided. ' +\n                    'Consider removing \"requestHeaders\" if you experience performances issues.'\n            );\n        } else {\n            this.loader = new ImageLoader();\n            if (this.viewer.config.withCredentials) {\n                this.loader.setWithCredentials(true);\n            }\n        }\n\n        this.viewer.addEventListener(events.PositionUpdatedEvent.type, this);\n        this.viewer.addEventListener(events.ZoomUpdatedEvent.type, this);\n    }\n\n    override destroy() {\n        this.viewer.addEventListener(events.PositionUpdatedEvent.type, this);\n        this.viewer.addEventListener(events.ZoomUpdatedEvent.type, this);\n\n        this.__cleanup();\n\n        this.state.errorMaterial?.map?.dispose();\n        this.state.errorMaterial?.dispose();\n\n        delete this.state.geom;\n        delete this.state.errorMaterial;\n\n        super.destroy();\n    }\n\n    /**\n     * @internal\n     */\n    handleEvent(e: Event) {\n        if (e instanceof events.PositionUpdatedEvent || e instanceof events.ZoomUpdatedEvent) {\n            this.__refresh();\n        }\n    }\n\n    override supportsTransition(panorama: CubemapTilesPanorama) {\n        return !!panorama.baseUrl;\n    }\n\n    override supportsPreload(panorama: CubemapTilesPanorama) {\n        return !!panorama.baseUrl;\n    }\n\n    override loadTexture(panorama: CubemapTilesPanorama): Promise<CubemapTexture> {\n        if (typeof panorama !== 'object' || !panorama.faceSize || !panorama.nbTiles || !panorama.tileUrl) {\n            return Promise.reject(new PSVError('Invalid panorama configuration, are you using the right adapter?'));\n        }\n        if (panorama.nbTiles > CUBE_SEGMENTS) {\n            return Promise.reject(new PSVError(`Panorama nbTiles must not be greater than ${CUBE_SEGMENTS}.`));\n        }\n        if (!MathUtils.isPowerOfTwo(panorama.nbTiles)) {\n            return Promise.reject(new PSVError('Panorama nbTiles must be power of 2.'));\n        }\n\n        if (panorama.baseUrl) {\n            if (!this.adapter) {\n                if (!CubemapAdapter) {\n                    throw new PSVError('CubemapTilesAdapter requires CubemapAdapter');\n                }\n\n                this.adapter = new CubemapAdapter(this.viewer, {\n                    blur: this.config.baseBlur,\n                });\n            }\n\n            return this.adapter.loadTexture(panorama.baseUrl).then((textureData) => ({\n                panorama: panorama,\n                texture: textureData.texture,\n            }));\n        } else {\n            return Promise.resolve({ panorama, texture: null });\n        }\n    }\n\n    createMesh(scale = 1): CubemapMesh {\n        const cubeSize = CONSTANTS.SPHERE_RADIUS * 2 * scale;\n        const geometry = new BoxGeometry(cubeSize, cubeSize, cubeSize, CUBE_SEGMENTS, CUBE_SEGMENTS, CUBE_SEGMENTS)\n            .scale(1, 1, -1)\n            .toNonIndexed() as BoxGeometry;\n\n        geometry.clearGroups();\n        for (let i = 0, k = 0; i < NB_VERTICES; i += NB_VERTICES_BY_FACE) {\n            geometry.addGroup(i, NB_VERTICES_BY_FACE, k++);\n        }\n\n        geometry.setAttribute(ATTR_ORIGINAL_UV, (geometry.getAttribute(ATTR_UV) as BufferAttribute).clone());\n\n        return new Mesh(geometry, []);\n    }\n\n    /**\n     * Applies the base texture and starts the loading of tiles\n     */\n    setTexture(mesh: CubemapMesh, textureData: CubemapTexture, transition: boolean) {\n        const { panorama, texture } = textureData;\n\n        if (transition) {\n            this.__setTexture(mesh, texture);\n            return;\n        }\n\n        this.__cleanup();\n        this.__setTexture(mesh, texture);\n\n        this.state.materials = mesh.material;\n        this.state.geom = mesh.geometry;\n        this.state.geom.setAttribute(ATTR_UV, (this.state.geom.getAttribute(ATTR_ORIGINAL_UV) as BufferAttribute).clone());\n\n        this.state.tileSize = panorama.faceSize / panorama.nbTiles;\n        this.state.facesByTile = CUBE_SEGMENTS / panorama.nbTiles;\n\n        // this.psv.renderer.scene.add(createWireFrame(this.state.geom));\n\n        setTimeout(() => this.__refresh(true));\n    }\n\n    private __setTexture(mesh: CubemapMesh, texture: Texture[]) {\n        for (let i = 0; i < 6; i++) {\n            let material;\n            if (texture) {\n                if (this.config.flipTopBottom && (i === 2 || i === 3)) {\n                    texture[i].center = new Vector2(0.5, 0.5);\n                    texture[i].rotation = Math.PI;\n                }\n\n                material = new MeshBasicMaterial({ map: texture[i] });\n            } else {\n                material = new MeshBasicMaterial({ opacity: 0, transparent: true });\n            }\n\n            for (let j = 0; j < NB_GROUPS_BY_FACE; j++) {\n                mesh.material.push(material);\n            }\n        }\n    }\n\n    setTextureOpacity(mesh: CubemapMesh, opacity: number) {\n        for (let i = 0; i < 6; i++) {\n            mesh.material[i * NB_GROUPS_BY_FACE].opacity = opacity;\n            mesh.material[i * NB_GROUPS_BY_FACE].transparent = opacity < 1;\n        }\n    }\n\n    /**\n     * @throws {@link PSVError} always\n     */\n    setOverlay(): void {\n        throw new PSVError('EquirectangularTilesAdapter does not support overlay');\n    }\n\n    disposeTexture(textureData: CubemapTexture) {\n        textureData.texture?.forEach((texture) => texture.dispose());\n    }\n\n    /**\n     * Compute visible tiles and load them\n     */\n    // @ts-ignore unused paramater\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    private __refresh(init = false) {\n        if (!this.state.geom) {\n            return;\n        }\n\n        const camera = this.viewer.renderer.camera;\n        camera.updateMatrixWorld();\n        projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n        frustum.setFromProjectionMatrix(projScreenMatrix);\n\n        const panorama: CubemapTilesPanorama = this.viewer.config.panorama;\n        const verticesPosition = this.state.geom.getAttribute(ATTR_POSITION) as BufferAttribute;\n        const tilesToLoad: CubemapTile[] = [];\n\n        for (let face = 0; face < 6; face++) {\n            for (let col = 0; col < panorama.nbTiles; col++) {\n                for (let row = 0; row < panorama.nbTiles; row++) {\n                    // for each tile, find the vertices corresponding to the four corners\n                    // if at least one vertex is visible, the tile must be loaded\n                    // for larger tiles we also test the four edges centers and the tile center\n                    const verticesIndex = [];\n\n                    // top-left\n                    const v0 = face * NB_VERTICES_BY_PLANE\n                        + row * this.state.facesByTile * CUBE_SEGMENTS * NB_VERTICES_BY_FACE\n                        + col * this.state.facesByTile * NB_VERTICES_BY_FACE;\n\n                    // bottom-left\n                    const v1 = v0 + CUBE_SEGMENTS * NB_VERTICES_BY_FACE * (this.state.facesByTile - 1) + 1;\n\n                    // bottom-right\n                    const v2 = v1 + this.state.facesByTile * NB_VERTICES_BY_FACE - 3;\n\n                    // top-right\n                    const v3 = v0 + this.state.facesByTile * NB_VERTICES_BY_FACE - 1;\n\n                    verticesIndex.push(v0, v1, v2, v3);\n\n                    if (this.state.facesByTile >= CUBE_SEGMENTS / 2) {\n                        // top-center\n                        const v4 = v0 + (this.state.facesByTile / 2) * NB_VERTICES_BY_FACE - 1;\n\n                        // bottom-center\n                        const v5 = v1 + (this.state.facesByTile / 2) * NB_VERTICES_BY_FACE - 3;\n\n                        // left-center\n                        const v6 = v0 + CUBE_SEGMENTS * NB_VERTICES_BY_FACE * (this.state.facesByTile / 2 - 1) + 1;\n\n                        // right-center\n                        const v7 = v6 + this.state.facesByTile * NB_VERTICES_BY_FACE - 3;\n\n                        // center-center\n                        const v8 = v6 + (this.state.facesByTile / 2) * NB_VERTICES_BY_FACE;\n\n                        verticesIndex.push(v4, v5, v6, v7, v8);\n                    }\n\n                    // if (init && face === 5 && col === 0 && row === 0) {\n                    //   verticesIndex.forEach((vertexIdx) => {\n                    //     this.psv.renderer.scene.add(createDot(\n                    //       verticesPosition.getX(vertexIdx),\n                    //       verticesPosition.getY(vertexIdx),\n                    //       verticesPosition.getZ(vertexIdx)\n                    //     ));\n                    //   });\n                    // }\n\n                    const vertexVisible = verticesIndex.some((vertexIdx) => {\n                        vertexPosition.set(\n                            verticesPosition.getX(vertexIdx),\n                            verticesPosition.getY(vertexIdx),\n                            verticesPosition.getZ(vertexIdx)\n                        );\n                        vertexPosition.applyEuler(this.viewer.renderer.sphereCorrection);\n                        return frustum.containsPoint(vertexPosition);\n                    });\n\n                    if (vertexVisible) {\n                        const angle = vertexPosition.angleTo(this.viewer.state.direction);\n                        tilesToLoad.push({ face, col, row, angle });\n                    }\n                }\n            }\n        }\n\n        this.__loadTiles(tilesToLoad);\n    }\n\n    /**\n     * Loads tiles and change existing tiles priority\n     */\n    private __loadTiles(tiles: CubemapTile[]) {\n        this.queue.disableAllTasks();\n\n        tiles.forEach((tile) => {\n            const id = tileId(tile);\n\n            if (this.state.tiles[id]) {\n                this.queue.setPriority(id, tile.angle);\n            } else {\n                this.state.tiles[id] = true;\n                this.queue.enqueue(new Task(id, tile.angle, (task) => this.__loadTile(tile, task)));\n            }\n        });\n\n        this.queue.start();\n    }\n\n    /**\n     * Loads and draw a tile\n     */\n    private __loadTile(tile: CubemapTile, task: Task): Promise<any> {\n        const panorama = this.viewer.config.panorama;\n\n        let { col, row } = tile;\n        if (this.config.flipTopBottom && (tile.face === 2 || tile.face === 3)) {\n            col = panorama.nbTiles - col - 1;\n            row = panorama.nbTiles - row - 1;\n        }\n        const url = panorama.tileUrl(CUBE_HASHMAP[tile.face], col, row);\n\n        if (!url) {\n            return Promise.resolve();\n        }\n\n        return this.__loadImage(url)\n            .then((image) => {\n                if (!task.isCancelled()) {\n                    const material = new MeshBasicMaterial({ map: utils.createTexture(image) });\n                    this.__swapMaterial(tile.face, tile.col, tile.row, material);\n                    this.viewer.needsUpdate();\n                }\n            })\n            .catch(() => {\n                if (!task.isCancelled() && this.config.showErrorTile) {\n                    if (!this.state.errorMaterial) {\n                        this.state.errorMaterial = buildErrorMaterial(this.state.tileSize, this.state.tileSize);\n                    }\n                    this.__swapMaterial(tile.face, tile.col, tile.row, this.state.errorMaterial);\n                    this.viewer.needsUpdate();\n                }\n            });\n    }\n\n    private __loadImage(url: string): Promise<HTMLImageElement> {\n        if (this.loader) {\n            return new Promise((resolve, reject) => {\n                this.loader.load(url, resolve, undefined, reject);\n            });\n        } else {\n            return this.viewer.textureLoader.loadImage(url);\n        }\n    }\n\n    /**\n     * Applies a new texture to the faces\n     */\n    private __swapMaterial(face: number, col: number, row: number, material: MeshBasicMaterial) {\n        const uvs = this.state.geom.getAttribute(ATTR_UV) as BufferAttribute;\n\n        for (let c = 0; c < this.state.facesByTile; c++) {\n            for (let r = 0; r < this.state.facesByTile; r++) {\n                // position of the face (two triangles of the same square)\n                const faceCol = col * this.state.facesByTile + c;\n                const faceRow = row * this.state.facesByTile + r;\n\n                // first vertex for this face (6 vertices in total)\n                const firstVertex = NB_VERTICES_BY_PLANE * face + 6 * (CUBE_SEGMENTS * faceRow + faceCol);\n\n                // swap material\n                const matIndex = this.state.geom.groups.find((g) => g.start === firstVertex).materialIndex;\n                this.state.materials[matIndex] = material;\n\n                // define new uvs\n                let top = 1 - r / this.state.facesByTile;\n                let bottom = 1 - (r + 1) / this.state.facesByTile;\n                let left = c / this.state.facesByTile;\n                let right = (c + 1) / this.state.facesByTile;\n\n                if (this.config.flipTopBottom && (face === 2 || face === 3)) {\n                    top = 1 - top;\n                    bottom = 1 - bottom;\n                    left = 1 - left;\n                    right = 1 - right;\n                }\n\n                uvs.setXY(firstVertex, left, top);\n                uvs.setXY(firstVertex + 1, left, bottom);\n                uvs.setXY(firstVertex + 2, right, top);\n                uvs.setXY(firstVertex + 3, left, bottom);\n                uvs.setXY(firstVertex + 4, right, bottom);\n                uvs.setXY(firstVertex + 5, right, top);\n            }\n        }\n\n        uvs.needsUpdate = true;\n    }\n\n    /**\n     * Clears loading queue, dispose all materials\n     */\n    private __cleanup() {\n        this.queue.clear();\n        this.state.tiles = {};\n\n        this.state.materials.forEach((mat) => {\n            mat?.map?.dispose();\n            mat?.dispose();\n        });\n        this.state.materials.length = 0;\n    }\n}\n","/**\n * @internal\n */\nconst enum Status {\n    DISABLED,\n    PENDING,\n    RUNNING,\n    CANCELLED,\n    DONE,\n    ERROR,\n}\n\n/**\n * @internal\n */\nexport class Task {\n    status: Status = Status.PENDING;\n\n    constructor(\n        public readonly id: string,\n        public priority: number,\n        private readonly fn: (task: Task) => Promise<any>\n    ) {}\n\n    start() {\n        this.status = Status.RUNNING;\n        return this.fn(this).then(\n            () => {\n                this.status = Status.DONE;\n            },\n            () => {\n                this.status = Status.ERROR;\n            }\n        );\n    }\n\n    cancel() {\n        this.status = Status.CANCELLED;\n    }\n\n    isCancelled() {\n        return this.status === Status.CANCELLED;\n    }\n}\n\n/**\n * @internal\n */\nexport class Queue {\n    private runningTasks: Record<string, boolean> = {};\n    private tasks: Record<string, Task> = {};\n\n    constructor(private readonly concurency = 4) {}\n\n    enqueue(task: Task) {\n        this.tasks[task.id] = task;\n    }\n\n    clear() {\n        Object.values(this.tasks).forEach((task) => task.cancel());\n        this.tasks = {};\n        this.runningTasks = {};\n    }\n\n    setPriority(taskId: string, priority: number) {\n        const task = this.tasks[taskId];\n        if (task) {\n            task.priority = priority;\n            if (task.status === Status.DISABLED) {\n                task.status = Status.PENDING;\n            }\n        }\n    }\n\n    disableAllTasks() {\n        Object.values(this.tasks).forEach((task) => {\n            task.status = Status.DISABLED;\n        });\n    }\n\n    start() {\n        if (Object.keys(this.runningTasks).length >= this.concurency) {\n            return;\n        }\n\n        const nextTask = Object.values(this.tasks)\n            .filter((task) => task.status === Status.PENDING)\n            .sort((a, b) => b.priority - a.priority)\n            .pop();\n\n        if (nextTask) {\n            this.runningTasks[nextTask.id] = true;\n\n            nextTask.start().then(() => {\n                if (!nextTask.isCancelled()) {\n                    delete this.tasks[nextTask.id];\n                    delete this.runningTasks[nextTask.id];\n                    this.start();\n                }\n            });\n\n            this.start(); // start tasks until max concurrency is reached\n        }\n    }\n}\n","import {\n    BufferGeometry,\n    CanvasTexture,\n    LineSegments,\n    Material,\n    Mesh,\n    MeshBasicMaterial,\n    Object3D,\n    SphereGeometry,\n    WireframeGeometry,\n} from 'three';\n\n/**\n * Generates an material for errored tiles\n * @internal\n */\nexport function buildErrorMaterial(width: number, height: number): MeshBasicMaterial {\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n\n    const ctx = canvas.getContext('2d');\n\n    ctx.fillStyle = '#333';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    ctx.font = `${canvas.width / 5}px serif`;\n    ctx.fillStyle = '#a22';\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n    ctx.fillText('⚠', canvas.width / 2, canvas.height / 2);\n\n    const texture = new CanvasTexture(canvas);\n    return new MeshBasicMaterial({ map: texture });\n}\n\n/**\n * Creates a wireframe geometry, for debug\n * @internal\n */\nexport function createWireFrame(geometry: BufferGeometry): Object3D {\n    const wireframe = new WireframeGeometry(geometry);\n    const line = new LineSegments<WireframeGeometry, Material>(wireframe);\n    line.material.depthTest = false;\n    line.material.opacity = 0.25;\n    line.material.transparent = true;\n    return line;\n}\n\n/**\n * Creates a small red sphere, for debug\n * @internal\n */\nexport function createDot(x: number, y: number, z: number) {\n    const geom = new SphereGeometry(0.1);\n    const material = new MeshBasicMaterial({ color: 0xff0000 });\n    const mesh = new Mesh(geom, material);\n    mesh.position.set(x, y, z);\n    return mesh;\n}\n"],"mappings":";;;;;;;AACA,SAAS,iBAAiB,WAAW,QAAQ,UAAU,aAAa;AACpE,SAAS,sBAAsB;AAC/B;AAAA,EACI;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,QAAAA;AAAA,EACA,qBAAAC;AAAA,EAEA;AAAA,EACA;AAAA,OACG;;;ACAA,IAAM,OAAN,MAAW;AAAA,EAGd,YACoB,IACT,UACU,IACnB;AAHkB;AACT;AACU;AALrB,kBAAiB;AAAA,EAMd;AAAA,EAEH,QAAQ;AACJ,SAAK,SAAS;AACd,WAAO,KAAK,GAAG,IAAI,EAAE;AAAA,MACjB,MAAM;AACF,aAAK,SAAS;AAAA,MAClB;AAAA,MACA,MAAM;AACF,aAAK,SAAS;AAAA,MAClB;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,SAAS;AACL,SAAK,SAAS;AAAA,EAClB;AAAA,EAEA,cAAc;AACV,WAAO,KAAK,WAAW;AAAA,EAC3B;AACJ;AAKO,IAAM,QAAN,MAAY;AAAA,EAIf,YAA6B,aAAa,GAAG;AAAhB;AAH7B,SAAQ,eAAwC,CAAC;AACjD,SAAQ,QAA8B,CAAC;AAAA,EAEO;AAAA,EAE9C,QAAQ,MAAY;AAChB,SAAK,MAAM,KAAK,EAAE,IAAI;AAAA,EAC1B;AAAA,EAEA,QAAQ;AACJ,WAAO,OAAO,KAAK,KAAK,EAAE,QAAQ,CAAC,SAAS,KAAK,OAAO,CAAC;AACzD,SAAK,QAAQ,CAAC;AACd,SAAK,eAAe,CAAC;AAAA,EACzB;AAAA,EAEA,YAAY,QAAgB,UAAkB;AAC1C,UAAM,OAAO,KAAK,MAAM,MAAM;AAC9B,QAAI,MAAM;AACN,WAAK,WAAW;AAChB,UAAI,KAAK,WAAW,kBAAiB;AACjC,aAAK,SAAS;AAAA,MAClB;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,kBAAkB;AACd,WAAO,OAAO,KAAK,KAAK,EAAE,QAAQ,CAAC,SAAS;AACxC,WAAK,SAAS;AAAA,IAClB,CAAC;AAAA,EACL;AAAA,EAEA,QAAQ;AACJ,QAAI,OAAO,KAAK,KAAK,YAAY,EAAE,UAAU,KAAK,YAAY;AAC1D;AAAA,IACJ;AAEA,UAAM,WAAW,OAAO,OAAO,KAAK,KAAK,EACpC,OAAO,CAAC,SAAS,KAAK,WAAW,eAAc,EAC/C,KAAK,CAAC,GAAG,MAAM,EAAE,WAAW,EAAE,QAAQ,EACtC,IAAI;AAET,QAAI,UAAU;AACV,WAAK,aAAa,SAAS,EAAE,IAAI;AAEjC,eAAS,MAAM,EAAE,KAAK,MAAM;AACxB,YAAI,CAAC,SAAS,YAAY,GAAG;AACzB,iBAAO,KAAK,MAAM,SAAS,EAAE;AAC7B,iBAAO,KAAK,aAAa,SAAS,EAAE;AACpC,eAAK,MAAM;AAAA,QACf;AAAA,MACJ,CAAC;AAED,WAAK,MAAM;AAAA,IACf;AAAA,EACJ;AACJ;;;ACxGA;AAAA,EAEI;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,OACG;AAMA,SAAS,mBAAmB,OAAe,QAAmC;AACjF,QAAM,SAAS,SAAS,cAAc,QAAQ;AAC9C,SAAO,QAAQ;AACf,SAAO,SAAS;AAEhB,QAAM,MAAM,OAAO,WAAW,IAAI;AAElC,MAAI,YAAY;AAChB,MAAI,SAAS,GAAG,GAAG,OAAO,OAAO,OAAO,MAAM;AAC9C,MAAI,OAAO,GAAG,OAAO,QAAQ;AAC7B,MAAI,YAAY;AAChB,MAAI,YAAY;AAChB,MAAI,eAAe;AACnB,MAAI,SAAS,UAAK,OAAO,QAAQ,GAAG,OAAO,SAAS,CAAC;AAErD,QAAM,UAAU,IAAI,cAAc,MAAM;AACxC,SAAO,IAAI,kBAAkB,EAAE,KAAK,QAAQ,CAAC;AACjD;;;AFTA,IAAM,gBAAgB;AACtB,IAAM,sBAAsB;AAC5B,IAAM,uBAAuB,sBAAsB,gBAAgB;AACnE,IAAM,cAAc,IAAI;AACxB,IAAM,oBAAoB,gBAAgB;AAE1C,IAAM,eAAe,CAAC,QAAQ,SAAS,OAAO,UAAU,QAAQ,OAAO;AAEvE,IAAM,UAAU;AAChB,IAAM,mBAAmB;AACzB,IAAM,gBAAgB;AAEtB,SAAS,OAAO,MAAmB;AAC/B,SAAO,GAAG,KAAK,QAAQ,KAAK,OAAO,KAAK;AAC5C;AAEA,IAAM,YAAY,MAAM,gBAA2C;AAAA,EAC/D,eAAe;AAAA,EACf,eAAe;AAAA,EACf,UAAU;AAAA,EACV,MAAM;AACV,CAAC;AAED,IAAM,UAAU,IAAI,QAAQ;AAC5B,IAAM,mBAAmB,IAAI,QAAQ;AACrC,IAAM,iBAAiB,IAAI,QAAQ;AAK5B,IAAM,sBAAN,cAAkC,gBAAiD;AAAA,EAoBtF,YAAY,QAAgB,QAAmC;AAC3D,UAAM,MAAM;AAdhB,SAAiB,QAAQ;AAAA,MACrB,UAAU;AAAA,MACV,aAAa;AAAA,MACb,OAAO,CAAC;AAAA,MACR,MAAM;AAAA,MACN,WAAW,CAAC;AAAA,MACZ,eAAe;AAAA,IACnB;AAGA,SAAiB,QAAQ,IAAI,MAAM;AAM/B,SAAK,SAAS,UAAU,MAAM;AAE9B,QAAI,KAAK,OAAO,OAAO,gBAAgB;AACnC,YAAM;AAAA,QACF;AAAA,MAEJ;AAAA,IACJ,OAAO;AACH,WAAK,SAAS,IAAI,YAAY;AAC9B,UAAI,KAAK,OAAO,OAAO,iBAAiB;AACpC,aAAK,OAAO,mBAAmB,IAAI;AAAA,MACvC;AAAA,IACJ;AAEA,SAAK,OAAO,iBAAiB,OAAO,qBAAqB,MAAM,IAAI;AACnE,SAAK,OAAO,iBAAiB,OAAO,iBAAiB,MAAM,IAAI;AAAA,EACnE;AAAA,EAES,UAAU;AACf,SAAK,OAAO,iBAAiB,OAAO,qBAAqB,MAAM,IAAI;AACnE,SAAK,OAAO,iBAAiB,OAAO,iBAAiB,MAAM,IAAI;AAE/D,SAAK,UAAU;AAEf,SAAK,MAAM,eAAe,KAAK,QAAQ;AACvC,SAAK,MAAM,eAAe,QAAQ;AAElC,WAAO,KAAK,MAAM;AAClB,WAAO,KAAK,MAAM;AAElB,UAAM,QAAQ;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,GAAU;AAClB,QAAI,aAAa,OAAO,wBAAwB,aAAa,OAAO,kBAAkB;AAClF,WAAK,UAAU;AAAA,IACnB;AAAA,EACJ;AAAA,EAES,mBAAmB,UAAgC;AACxD,WAAO,CAAC,CAAC,SAAS;AAAA,EACtB;AAAA,EAES,gBAAgB,UAAgC;AACrD,WAAO,CAAC,CAAC,SAAS;AAAA,EACtB;AAAA,EAES,YAAY,UAAyD;AAC1E,QAAI,OAAO,aAAa,YAAY,CAAC,SAAS,YAAY,CAAC,SAAS,WAAW,CAAC,SAAS,SAAS;AAC9F,aAAO,QAAQ,OAAO,IAAI,SAAS,kEAAkE,CAAC;AAAA,IAC1G;AACA,QAAI,SAAS,UAAU,eAAe;AAClC,aAAO,QAAQ,OAAO,IAAI,SAAS,6CAA6C,gBAAgB,CAAC;AAAA,IACrG;AACA,QAAI,CAAC,UAAU,aAAa,SAAS,OAAO,GAAG;AAC3C,aAAO,QAAQ,OAAO,IAAI,SAAS,sCAAsC,CAAC;AAAA,IAC9E;AAEA,QAAI,SAAS,SAAS;AAClB,UAAI,CAAC,KAAK,SAAS;AACf,YAAI,CAAC,gBAAgB;AACjB,gBAAM,IAAI,SAAS,6CAA6C;AAAA,QACpE;AAEA,aAAK,UAAU,IAAI,eAAe,KAAK,QAAQ;AAAA,UAC3C,MAAM,KAAK,OAAO;AAAA,QACtB,CAAC;AAAA,MACL;AAEA,aAAO,KAAK,QAAQ,YAAY,SAAS,OAAO,EAAE,KAAK,CAAC,iBAAiB;AAAA,QACrE;AAAA,QACA,SAAS,YAAY;AAAA,MACzB,EAAE;AAAA,IACN,OAAO;AACH,aAAO,QAAQ,QAAQ,EAAE,UAAU,SAAS,KAAK,CAAC;AAAA,IACtD;AAAA,EACJ;AAAA,EAEA,WAAW,QAAQ,GAAgB;AAC/B,UAAM,WAAW,UAAU,gBAAgB,IAAI;AAC/C,UAAM,WAAW,IAAI,YAAY,UAAU,UAAU,UAAU,eAAe,eAAe,aAAa,EACrG,MAAM,GAAG,GAAG,EAAE,EACd,aAAa;AAElB,aAAS,YAAY;AACrB,aAAS,IAAI,GAAG,IAAI,GAAG,IAAI,aAAa,KAAK,qBAAqB;AAC9D,eAAS,SAAS,GAAG,qBAAqB,GAAG;AAAA,IACjD;AAEA,aAAS,aAAa,kBAAmB,SAAS,aAAa,OAAO,EAAsB,MAAM,CAAC;AAEnG,WAAO,IAAIC,MAAK,UAAU,CAAC,CAAC;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKA,WAAW,MAAmB,aAA6B,YAAqB;AAC5E,UAAM,EAAE,UAAU,QAAQ,IAAI;AAE9B,QAAI,YAAY;AACZ,WAAK,aAAa,MAAM,OAAO;AAC/B;AAAA,IACJ;AAEA,SAAK,UAAU;AACf,SAAK,aAAa,MAAM,OAAO;AAE/B,SAAK,MAAM,YAAY,KAAK;AAC5B,SAAK,MAAM,OAAO,KAAK;AACvB,SAAK,MAAM,KAAK,aAAa,SAAU,KAAK,MAAM,KAAK,aAAa,gBAAgB,EAAsB,MAAM,CAAC;AAEjH,SAAK,MAAM,WAAW,SAAS,WAAW,SAAS;AACnD,SAAK,MAAM,cAAc,gBAAgB,SAAS;AAIlD,eAAW,MAAM,KAAK,UAAU,IAAI,CAAC;AAAA,EACzC;AAAA,EAEQ,aAAa,MAAmB,SAAoB;AACxD,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,UAAI;AACJ,UAAI,SAAS;AACT,YAAI,KAAK,OAAO,kBAAkB,MAAM,KAAK,MAAM,IAAI;AACnD,kBAAQ,CAAC,EAAE,SAAS,IAAI,QAAQ,KAAK,GAAG;AACxC,kBAAQ,CAAC,EAAE,WAAW,KAAK;AAAA,QAC/B;AAEA,mBAAW,IAAIC,mBAAkB,EAAE,KAAK,QAAQ,CAAC,EAAE,CAAC;AAAA,MACxD,OAAO;AACH,mBAAW,IAAIA,mBAAkB,EAAE,SAAS,GAAG,aAAa,KAAK,CAAC;AAAA,MACtE;AAEA,eAAS,IAAI,GAAG,IAAI,mBAAmB,KAAK;AACxC,aAAK,SAAS,KAAK,QAAQ;AAAA,MAC/B;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,kBAAkB,MAAmB,SAAiB;AAClD,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AACxB,WAAK,SAAS,IAAI,iBAAiB,EAAE,UAAU;AAC/C,WAAK,SAAS,IAAI,iBAAiB,EAAE,cAAc,UAAU;AAAA,IACjE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,aAAmB;AACf,UAAM,IAAI,SAAS,sDAAsD;AAAA,EAC7E;AAAA,EAEA,eAAe,aAA6B;AACxC,gBAAY,SAAS,QAAQ,CAAC,YAAY,QAAQ,QAAQ,CAAC;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,UAAU,OAAO,OAAO;AAC5B,QAAI,CAAC,KAAK,MAAM,MAAM;AAClB;AAAA,IACJ;AAEA,UAAM,SAAS,KAAK,OAAO,SAAS;AACpC,WAAO,kBAAkB;AACzB,qBAAiB,iBAAiB,OAAO,kBAAkB,OAAO,kBAAkB;AACpF,YAAQ,wBAAwB,gBAAgB;AAEhD,UAAM,WAAiC,KAAK,OAAO,OAAO;AAC1D,UAAM,mBAAmB,KAAK,MAAM,KAAK,aAAa,aAAa;AACnE,UAAM,cAA6B,CAAC;AAEpC,aAAS,OAAO,GAAG,OAAO,GAAG,QAAQ;AACjC,eAAS,MAAM,GAAG,MAAM,SAAS,SAAS,OAAO;AAC7C,iBAAS,MAAM,GAAG,MAAM,SAAS,SAAS,OAAO;AAI7C,gBAAM,gBAAgB,CAAC;AAGvB,gBAAM,KAAK,OAAO,uBACZ,MAAM,KAAK,MAAM,cAAc,gBAAgB,sBAC/C,MAAM,KAAK,MAAM,cAAc;AAGrC,gBAAM,KAAK,KAAK,gBAAgB,uBAAuB,KAAK,MAAM,cAAc,KAAK;AAGrF,gBAAM,KAAK,KAAK,KAAK,MAAM,cAAc,sBAAsB;AAG/D,gBAAM,KAAK,KAAK,KAAK,MAAM,cAAc,sBAAsB;AAE/D,wBAAc,KAAK,IAAI,IAAI,IAAI,EAAE;AAEjC,cAAI,KAAK,MAAM,eAAe,gBAAgB,GAAG;AAE7C,kBAAM,KAAK,KAAM,KAAK,MAAM,cAAc,IAAK,sBAAsB;AAGrE,kBAAM,KAAK,KAAM,KAAK,MAAM,cAAc,IAAK,sBAAsB;AAGrE,kBAAM,KAAK,KAAK,gBAAgB,uBAAuB,KAAK,MAAM,cAAc,IAAI,KAAK;AAGzF,kBAAM,KAAK,KAAK,KAAK,MAAM,cAAc,sBAAsB;AAG/D,kBAAM,KAAK,KAAM,KAAK,MAAM,cAAc,IAAK;AAE/C,0BAAc,KAAK,IAAI,IAAI,IAAI,IAAI,EAAE;AAAA,UACzC;AAYA,gBAAM,gBAAgB,cAAc,KAAK,CAAC,cAAc;AACpD,2BAAe;AAAA,cACX,iBAAiB,KAAK,SAAS;AAAA,cAC/B,iBAAiB,KAAK,SAAS;AAAA,cAC/B,iBAAiB,KAAK,SAAS;AAAA,YACnC;AACA,2BAAe,WAAW,KAAK,OAAO,SAAS,gBAAgB;AAC/D,mBAAO,QAAQ,cAAc,cAAc;AAAA,UAC/C,CAAC;AAED,cAAI,eAAe;AACf,kBAAM,QAAQ,eAAe,QAAQ,KAAK,OAAO,MAAM,SAAS;AAChE,wBAAY,KAAK,EAAE,MAAM,KAAK,KAAK,MAAM,CAAC;AAAA,UAC9C;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAEA,SAAK,YAAY,WAAW;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKQ,YAAY,OAAsB;AACtC,SAAK,MAAM,gBAAgB;AAE3B,UAAM,QAAQ,CAAC,SAAS;AACpB,YAAM,KAAK,OAAO,IAAI;AAEtB,UAAI,KAAK,MAAM,MAAM,EAAE,GAAG;AACtB,aAAK,MAAM,YAAY,IAAI,KAAK,KAAK;AAAA,MACzC,OAAO;AACH,aAAK,MAAM,MAAM,EAAE,IAAI;AACvB,aAAK,MAAM,QAAQ,IAAI,KAAK,IAAI,KAAK,OAAO,CAAC,SAAS,KAAK,WAAW,MAAM,IAAI,CAAC,CAAC;AAAA,MACtF;AAAA,IACJ,CAAC;AAED,SAAK,MAAM,MAAM;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAKQ,WAAW,MAAmB,MAA0B;AAC5D,UAAM,WAAW,KAAK,OAAO,OAAO;AAEpC,QAAI,EAAE,KAAK,IAAI,IAAI;AACnB,QAAI,KAAK,OAAO,kBAAkB,KAAK,SAAS,KAAK,KAAK,SAAS,IAAI;AACnE,YAAM,SAAS,UAAU,MAAM;AAC/B,YAAM,SAAS,UAAU,MAAM;AAAA,IACnC;AACA,UAAM,MAAM,SAAS,QAAQ,aAAa,KAAK,IAAI,GAAG,KAAK,GAAG;AAE9D,QAAI,CAAC,KAAK;AACN,aAAO,QAAQ,QAAQ;AAAA,IAC3B;AAEA,WAAO,KAAK,YAAY,GAAG,EACtB,KAAK,CAAC,UAAU;AACb,UAAI,CAAC,KAAK,YAAY,GAAG;AACrB,cAAM,WAAW,IAAIA,mBAAkB,EAAE,KAAK,MAAM,cAAc,KAAK,EAAE,CAAC;AAC1E,aAAK,eAAe,KAAK,MAAM,KAAK,KAAK,KAAK,KAAK,QAAQ;AAC3D,aAAK,OAAO,YAAY;AAAA,MAC5B;AAAA,IACJ,CAAC,EACA,MAAM,MAAM;AACT,UAAI,CAAC,KAAK,YAAY,KAAK,KAAK,OAAO,eAAe;AAClD,YAAI,CAAC,KAAK,MAAM,eAAe;AAC3B,eAAK,MAAM,gBAAgB,mBAAmB,KAAK,MAAM,UAAU,KAAK,MAAM,QAAQ;AAAA,QAC1F;AACA,aAAK,eAAe,KAAK,MAAM,KAAK,KAAK,KAAK,KAAK,KAAK,MAAM,aAAa;AAC3E,aAAK,OAAO,YAAY;AAAA,MAC5B;AAAA,IACJ,CAAC;AAAA,EACT;AAAA,EAEQ,YAAY,KAAwC;AACxD,QAAI,KAAK,QAAQ;AACb,aAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACpC,aAAK,OAAO,KAAK,KAAK,SAAS,QAAW,MAAM;AAAA,MACpD,CAAC;AAAA,IACL,OAAO;AACH,aAAO,KAAK,OAAO,cAAc,UAAU,GAAG;AAAA,IAClD;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKQ,eAAe,MAAc,KAAa,KAAa,UAA6B;AACxF,UAAM,MAAM,KAAK,MAAM,KAAK,aAAa,OAAO;AAEhD,aAAS,IAAI,GAAG,IAAI,KAAK,MAAM,aAAa,KAAK;AAC7C,eAAS,IAAI,GAAG,IAAI,KAAK,MAAM,aAAa,KAAK;AAE7C,cAAM,UAAU,MAAM,KAAK,MAAM,cAAc;AAC/C,cAAM,UAAU,MAAM,KAAK,MAAM,cAAc;AAG/C,cAAM,cAAc,uBAAuB,OAAO,KAAK,gBAAgB,UAAU;AAGjF,cAAM,WAAW,KAAK,MAAM,KAAK,OAAO,KAAK,CAAC,MAAM,EAAE,UAAU,WAAW,EAAE;AAC7E,aAAK,MAAM,UAAU,QAAQ,IAAI;AAGjC,YAAI,MAAM,IAAI,IAAI,KAAK,MAAM;AAC7B,YAAI,SAAS,KAAK,IAAI,KAAK,KAAK,MAAM;AACtC,YAAI,OAAO,IAAI,KAAK,MAAM;AAC1B,YAAI,SAAS,IAAI,KAAK,KAAK,MAAM;AAEjC,YAAI,KAAK,OAAO,kBAAkB,SAAS,KAAK,SAAS,IAAI;AACzD,gBAAM,IAAI;AACV,mBAAS,IAAI;AACb,iBAAO,IAAI;AACX,kBAAQ,IAAI;AAAA,QAChB;AAEA,YAAI,MAAM,aAAa,MAAM,GAAG;AAChC,YAAI,MAAM,cAAc,GAAG,MAAM,MAAM;AACvC,YAAI,MAAM,cAAc,GAAG,OAAO,GAAG;AACrC,YAAI,MAAM,cAAc,GAAG,MAAM,MAAM;AACvC,YAAI,MAAM,cAAc,GAAG,OAAO,MAAM;AACxC,YAAI,MAAM,cAAc,GAAG,OAAO,GAAG;AAAA,MACzC;AAAA,IACJ;AAEA,QAAI,cAAc;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA,EAKQ,YAAY;AAChB,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,QAAQ,CAAC;AAEpB,SAAK,MAAM,UAAU,QAAQ,CAAC,QAAQ;AAClC,WAAK,KAAK,QAAQ;AAClB,WAAK,QAAQ;AAAA,IACjB,CAAC;AACD,SAAK,MAAM,UAAU,SAAS;AAAA,EAClC;AACJ;AAhZa,oBACgB,KAAK;AADrB,oBAEgB,mBAAmB;AAFnC,oBAGgB,kBAAkB;","names":["Mesh","MeshBasicMaterial","Mesh","MeshBasicMaterial"]}